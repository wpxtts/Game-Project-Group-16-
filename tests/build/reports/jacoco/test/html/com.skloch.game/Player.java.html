<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Player.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">com.skloch.game</a> &gt; <span class="el_source">Player.java</span></div><h1>Player.java</h1><pre class="source lang-java linenums">package com.skloch.game;

import com.badlogic.gdx.Game;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;

import java.util.ArrayList;

/**
 * A class handling everything needed to control and draw a player, including animation, movement and collision
 */
public class Player {
<span class="fc" id="L19">    public static String atlasConfig = &quot;../assets/Sprites/Player/player_sprites.atlas&quot;;</span>
<span class="fc" id="L20">    public static String playerSprite = &quot;../assets/Sprites/Player/player_sprites.png&quot;;</span>
    // Hitboxes
    public Rectangle sprite, feet, eventHitbox;
    public float centreX, centreY;
<span class="fc" id="L24">    public int direction = 2; // 0 = up, 1 = right, 2 = down, 3 = left (like a clock)</span>
    public static final int up = 0;
    public static final int right = 1;
    public static final int left =3;
    public static final int down = 2;
    private TextureRegion currentFrame;
<span class="fc" id="L30">    private float stateTime = 0;</span>
    private final Array&lt;Animation&lt;TextureRegion&gt;&gt; walkingAnimation, idleAnimation;
    // Stats
<span class="fc" id="L33">    public float speed = 500f;</span>
    public Array&lt;GameObject&gt; collidables;
<span class="fc" id="L35">    public int scale = 4;</span>
    private Rectangle bounds;
    private GameObject closestObject;
    public boolean frozen, moving;

    public String avatar;

    /**
     * A player character, contains methods to move the player and update animations, also includes collision handling
     * and can be used to trigger events of objects near the player.
     * Includes a feet hitbox for collision and an event hitbox for triggering objects.
     * Call move() then draw the result of getCurrentAnimation() to use
     *
     * @param avatar &quot;avatar1&quot; for the more masculine character, &quot;avatar2&quot; for the more feminine character,
     *               player animations are packed in the player_sprites atlas
     */
<span class="fc" id="L51">    public Player (String avatar) {</span>
<span class="fc" id="L52">        this.avatar = avatar;</span>
        // Load the player's textures from the atlas
<span class="fc" id="L54">        TextureAtlas playerAtlas = new TextureAtlas(Gdx.files.internal(atlasConfig));</span>

<span class="fc" id="L56">        walkingAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;(4);</span>
<span class="fc" id="L57">        idleAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;(4);</span>

        // Load walking animation from Sprite atlas
<span class="fc" id="L60">        walkingAnimation.add(</span>
<span class="fc" id="L61">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L62">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L63">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L64">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_left&quot;), Animation.PlayMode.LOOP));</span>
        // Load idle animation
<span class="fc" id="L66">        idleAnimation.add(</span>
<span class="fc" id="L67">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L68">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L69">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L70">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_left&quot;), Animation.PlayMode.LOOP)</span>
        );

<span class="fc" id="L73">        collidables = new Array&lt;GameObject&gt;();</span>

        // Sprite is a rectangle covering the whole player
<span class="fc" id="L76">        sprite = new Rectangle(0, 0, 17*scale, 28*scale);</span>

        // Feet is a rectangle just covering the player's feet, so is better for collision
<span class="fc" id="L79">        feet = new Rectangle(4*scale, 0, 9*scale, 7*scale);</span>

        // Hitbox for triggering events with objects
<span class="fc" id="L82">        float hitboxScaleX = 2.2f;</span>
<span class="fc" id="L83">        float hitboxScaley = 1.7f;</span>
<span class="fc" id="L84">        eventHitbox = new Rectangle(</span>
<span class="fc" id="L85">                sprite.getX() - (sprite.getWidth()*hitboxScaleX - sprite.getWidth()) / 2,</span>
<span class="fc" id="L86">                sprite.getY() - (sprite.getHeight()*hitboxScaley - sprite.getHeight()) / 2,</span>
<span class="fc" id="L87">                sprite.getWidth()*hitboxScaleX,</span>
<span class="fc" id="L88">                sprite.getHeight()*hitboxScaley</span>
        );

<span class="fc" id="L91">    }</span>

    /**
     * Handles all the logic involved in moving the player given keyboard inputs
     * If the player encounters an object, they will not be alowed to move into the space, but will attempt to
     * 'slide' off of it.
     * Also updates the player's animation
     *
     * &lt;p&gt;&lt;/p&gt;
     *
     * Also locates the nearest object after moving, which can be used to trigger events
     *
     * @param delta The time passed since the previous render
     */
    public void move (float delta) {
        // Updates the player's position based on keys being pressed
        // Also updates the direction they are facing, and whether they are currently moving
        // And also does collision

<span class="nc" id="L110">        moving = false;</span>
        // To check collision, store the player's current position
<span class="nc" id="L112">        float oldX = sprite.x;</span>
<span class="nc" id="L113">        float oldY = sprite.y;</span>
<span class="nc" id="L114">        float oldFeetX = feet.x;</span>
<span class="nc" id="L115">        float oldFeetY = feet.y;</span>

        // If not frozen, react to keyboard input presses
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (!frozen) {</span>
            // Move the player and their 2 other hitboxes
<span class="nc" id="L120">            moving = false;</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {</span>
<span class="nc" id="L122">                direction = movePlayer(left,speed,delta);</span>
<span class="nc" id="L123">                moving = true;</span>
            }
<span class="nc bnc" id="L125" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {</span>
<span class="nc" id="L126">                direction = movePlayer(right,speed,delta);</span>
<span class="nc" id="L127">                moving = true;</span>
            }
<span class="nc bnc" id="L129" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.UP) || Gdx.input.isKeyPressed(Input.Keys.W)) {</span>
<span class="nc" id="L130">                direction = movePlayer(up,speed,delta);</span>
<span class="nc" id="L131">                moving = true;</span>
            }
<span class="nc bnc" id="L133" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S)) {</span>
<span class="nc" id="L134">                direction = movePlayer(down,speed,delta);</span>
<span class="nc" id="L135">                moving = true;</span>
            }


            // Get all objects you are colliding with
<span class="nc" id="L140">            ArrayList&lt;GameObject&gt; collidingObjects = collisionCheck();</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            for (GameObject collidingObject : collidingObjects){</span>

                // Find the direction that the player needs to be moved back to
                // Reset x
<span class="nc bnc" id="L145" title="All 4 branches missed.">                if (!(oldFeetX &lt; collidingObject.x + collidingObject.width</span>
                        &amp;&amp; oldFeetX + feet.width &gt; collidingObject.x)) {
<span class="nc" id="L147">                        this.setX(oldX);</span>
                }
                // If overlapping in y direction
<span class="nc bnc" id="L150" title="All 4 branches missed.">                if (!(oldFeetY &lt; collidingObject.y + collidingObject.height</span>
                        &amp;&amp; oldFeetY + feet.height &gt; collidingObject.y)) {
<span class="nc" id="L152">                    this.setY(oldY);</span>
                }
                // The above two are essentially the same code as Rectangle.overlaps()
                // Just separated into the x and y dimensions
<span class="nc" id="L156">            }</span>


            // Check the player is in bounds
<span class="nc" id="L160">            movePlayerWithinBounds();</span>
        }

<span class="nc" id="L163">        GameObject closestObject = findClosestInteractableObject();</span>

        // Increment the animation
<span class="nc" id="L166">        updateAnimation();</span>

<span class="nc" id="L168">    }</span>

    /**
     * Moves player in direction specified,
     * @param direction &quot;left&quot;,&quot;right&quot;,&quot;up&quot;, or &quot;down&quot; to indicate which direction to go in
     * @param speed
     * @param delta
     * @return
     */
    public int movePlayer(int direction,float speed, float delta){
        // Switch case to consider each of the different directions the player could go
<span class="nc bnc" id="L179" title="All 5 branches missed.">        switch(direction) {</span>
            case Player.left:
<span class="nc" id="L181">                this.setX(sprite.getX() - speed * delta); // Note: Setting all the values with a constant delta removes hitbox desyncing issues</span>
<span class="nc" id="L182">                break;</span>
            case Player.right:
<span class="nc" id="L184">                this.setX(sprite.getX() + speed * delta);</span>
<span class="nc" id="L185">                break;</span>
            case Player.up:
<span class="nc" id="L187">                this.setY(sprite.getY() + speed * delta);</span>
<span class="nc" id="L188">                break;</span>
            case Player.down:
<span class="nc" id="L190">                this.setY(sprite.getY() - speed * delta);</span>
<span class="nc" id="L191">                break;</span>
            default:
<span class="nc" id="L193">                throw new IllegalArgumentException(&quot;Direction must be up, down, left, or right.&quot;);</span>
        }
<span class="nc" id="L195">        return direction;</span>
    }

    /**
     * Returns all game objects player is colliding with
     * @return ArrayList of GameObject's that the player is colliding with
     */
    public ArrayList&lt;GameObject&gt; collisionCheck(){
        // Check if the player's feet are inside an object, if they are, move them back in that axis
<span class="nc" id="L204">        ArrayList&lt;GameObject&gt; collidingObjects = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        for (GameObject object : this.collidables) {</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            if (feet.overlaps(object)) {</span>
<span class="nc" id="L207">                collidingObjects.add(object);</span>
            }
<span class="nc" id="L209">        }</span>
<span class="nc" id="L210">        return collidingObjects;</span>
    }

    /**
     * Move player back within bounds if they aren't within bounds
     */
    public void movePlayerWithinBounds(){
        // Check the player is in bounds
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (bounds != null) {</span>
            // If player is out of bounds, move them back
<span class="nc bnc" id="L220" title="All 2 branches missed.">            if (feet.getX() &lt; bounds.getX()) {</span>
<span class="nc" id="L221">                sprite.x = bounds.getX()-4*scale;</span>
<span class="nc" id="L222">                feet.x = sprite.x + 4*scale;</span>
            }
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (feet.getX()+feet.getWidth() &gt; bounds.getWidth()) {</span>
<span class="nc" id="L225">                sprite.x = (bounds.getWidth() - feet.getWidth()) - (4*scale);</span>
<span class="nc" id="L226">                feet.x = sprite.x + 4*scale;</span>
            }
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if (feet.getY() &lt; bounds.getY()) {</span>
<span class="nc" id="L229">                sprite.y = bounds.getY();</span>
<span class="nc" id="L230">                feet.y = bounds.getY();</span>
            }
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (feet.getY()+feet.getHeight() &gt; bounds.getHeight()) {</span>
<span class="nc" id="L233">                sprite.y = bounds.getHeight()-feet.getHeight();</span>
<span class="nc" id="L234">                feet.y = sprite.y;</span>
            }
        }
<span class="nc" id="L237">    }</span>

    public GameObject findClosestInteractableObject(){
        // Find the closest object to the player so they can interact with it
<span class="nc" id="L241">        recalcCentre(); // Just recalculates the centre of the player now we have moved them</span>
<span class="nc" id="L242">        float distance = -1;</span>
<span class="nc" id="L243">        closestObject = null;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (GameObject object : this.collidables) {</span>
            // Check if this object is even interactable
<span class="nc bnc" id="L246" title="All 4 branches missed.">            if (object.get(&quot;event&quot;) != null || object.get(&quot;text&quot;) != null) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                if (eventHitbox.overlaps(object)) {</span>
                    // Check if this is the closest object to the player
<span class="nc bnc" id="L249" title="All 4 branches missed.">                    if (distance == -1 || distanceFrom(object) &lt; distance) {</span>
<span class="nc" id="L250">                        closestObject = object;</span>
<span class="nc" id="L251">                        distance = distanceFrom(object);</span>
                    }
                }
            }
<span class="nc" id="L255">        }</span>
<span class="nc" id="L256">        return closestObject;</span>
    }

    /**
     * Advances the current animation based on the time since the last render
     * The animation frame of the player can be grabbed with getCurrentFrame
     */
    public void updateAnimation() {
<span class="nc" id="L264">        stateTime += Gdx.graphics.getDeltaTime();</span>
        // Set the current frame of the animation
        // Show a different animation if the player is moving vs idling
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (moving) {</span>
<span class="nc" id="L268">            currentFrame = walkingAnimation.get(direction).getKeyFrame(stateTime);</span>
        } else {
<span class="nc" id="L270">            currentFrame = idleAnimation.get(direction).getKeyFrame(stateTime);</span>
        }
<span class="nc" id="L272">    }</span>

    /**
     * Returns whether the player's eventHitbox overlaps an object
     * Call getClosestObject to get the nearest interactable object.
     * findClosestInteractableObject needs to be called before this is called
     * which is done during move()
     *
     * @return true if a player is near enough an object to interact with it
     */
    public boolean nearObject() {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        return closestObject != null;</span>
    }

    /**
     * Returns the object that is closest to the player, calculated during move()
     * Needs to have findClosestInteractableObject run before it.
     *
     * @return A GameObject that is closest
     */
    public GameObject getClosestObject () {
<span class="nc" id="L293">        return closestObject;</span>
    }

    /**
     * Returns if the player is moving or not
     *
     * @return true if the player is moving
     */
    public boolean isMoving() {
<span class="nc" id="L302">        return moving;</span>
    }

    /**
     * Sets the player's state to moving or not moving, a not moving character will just display an idle animation
     *
     * @param moving The boolean to set moving to
     */
    public void setMoving(boolean moving) {
<span class="nc" id="L311">        this.moving = moving;</span>
<span class="nc" id="L312">    }</span>


    /**
     * Returns the current frame the player's animation is on
     *
     * @return TextureRegion the frame of the player's animation
     */
    public TextureRegion getCurrentFrame () {
        // Returns the current frame the player animation is on
<span class="nc" id="L322">        return currentFrame;</span>
    }

    /**
     * Sets the objects the player cannot move into as an Array of GameObjects
     *
     * @param collidables An array of GameObjects that the player should collide with
     */
    public void setCollidables (Array&lt;GameObject&gt; collidables) {
<span class="nc" id="L331">        this.collidables = collidables;</span>
<span class="nc" id="L332">    }</span>

    /**
     * Adds a GameObeject to the player's list of collidable objects
     *
     * @param object a GameObject for the player to collide with
     */
    public void addCollidable (GameObject object) {
<span class="nc" id="L340">        this.collidables.add(object);</span>
<span class="nc" id="L341">    }</span>

    /**
     * @return The X coordinate of the player
     */
    public float getX () {
<span class="nc" id="L347">        return sprite.getX();</span>
    }
    /**
     * @return The Y coordinate of the player
     */
    public float getY () {
<span class="nc" id="L353">        return sprite.getY();</span>
    }

    /**
     * @return The X coordinate of the centre point of the player's sprite rectangle
     */
    public float getCentreX () {
<span class="nc" id="L360">        return centreX;</span>
    }
    /**
     * @return The Y coordinate of the centre point of the player's sprite rectangle
     */
    public float getCentreY () {
<span class="nc" id="L366">        return centreY;</span>
    }

    /**
     * @return The Vector3 representation of the bottom left corner of the player's sprite hitbox
     */
    public Vector3 getPosAsVec3() {
<span class="nc" id="L373">        return new Vector3(</span>
<span class="nc" id="L374">                sprite.getX(),</span>
<span class="nc" id="L375">                sprite.getY(),</span>
                0
        );
    }

    /**
     * Sets the x coordinate of the player, updating all 3 hitboxes at once as opposed to just the sprite rectangle
     */
    public void setX (float x) {
<span class="nc" id="L384">        this.sprite.setX(x);</span>
<span class="nc" id="L385">        this.feet.setX(x + 4*scale);</span>
<span class="nc" id="L386">        this.eventHitbox.setX(this.sprite.getX() - (this.eventHitbox.getWidth() - sprite.getWidth()) / 2);</span>
<span class="nc" id="L387">        this.recalcCentre();</span>
<span class="nc" id="L388">    }</span>
    /**
     * Sets the Y coordinate of the player, updating all 3 hitboxes at once as opposed to just the sprite rectangle
     */
    public void setY (float y) {
<span class="nc" id="L393">        this.sprite.setY(y);</span>
<span class="nc" id="L394">        this.feet.setY(y);</span>
<span class="nc" id="L395">        this.eventHitbox.setY(this.sprite.getY() - (this.eventHitbox.getHeight() - sprite.getHeight()) / 2);</span>
<span class="nc" id="L396">        this.recalcCentre();</span>
<span class="nc" id="L397">    }</span>

    /**
     *
     * @param x The X coordinate to set the player to
     * @param y The Y coordinate to set the player to
     */
    public void setPos (float x, float y) {
<span class="nc" id="L405">        this.setX(x);</span>
<span class="nc" id="L406">        this.setY(y);</span>
<span class="nc" id="L407">    }</span>

    /**
     * Set a large rectangle that the player should be kept inside, set to null to set no bounds
     *
     * @param bounds The bounds of the playable map
     */
    public void setBounds (Rectangle bounds) {
        // Set a rectangle that the player should not leave
<span class="nc" id="L416">        this.bounds = bounds;</span>
<span class="nc" id="L417">    }</span>

    /**
     * Returns the euclidian distance from a GameObject to the centre of the player
     *
     * @param object The object to get the distance from
     * @return The distance from the object
     */
    private float distanceFrom (GameObject object) {
<span class="nc" id="L426">        return (float) Math.sqrt((Math.pow((centreX - object.centreX), 2) + Math.pow((centreY - object.centreY), 2)));</span>
    }

    /**
     * Recalculates the centre of the player, useful after moving the player
     */
    private void recalcCentre() {
<span class="nc" id="L433">        centreX = sprite.getX() + sprite.getWidth() / 2;</span>
<span class="nc" id="L434">        centreY = sprite.getY() + sprite.getHeight() / 2;</span>
<span class="nc" id="L435">    }</span>

    /**
     * Sets the player to frozen, a frozen player can be set to ignore keyboard inputs in render
     *
     * @param freeze The value to set frozen to
     */
    public void setFrozen (boolean freeze) {
<span class="nc" id="L443">        this.frozen = freeze;</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        if (freeze) {</span>
            // Set to non-moving frame
<span class="nc" id="L446">            currentFrame = idleAnimation.get(direction).getKeyFrame(stateTime);</span>
        }
<span class="nc" id="L448">    }</span>

    /**
     * @return true if the player is frozen
     */
    public boolean isFrozen () {
<span class="nc" id="L454">        return this.frozen;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>