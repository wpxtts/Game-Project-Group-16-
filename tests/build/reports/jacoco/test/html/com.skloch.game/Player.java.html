<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Player.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">com.skloch.game</a> &gt; <span class="el_source">Player.java</span></div><h1>Player.java</h1><pre class="source lang-java linenums">package com.skloch.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;

/**
 * A class handling everything needed to control and draw a player, including animation, movement and collision
 */
public class Player {
<span class="fc" id="L16">    public static String atlasConfig = &quot;../assets/Sprites/Player/player_sprites.atlas&quot;;</span>
<span class="fc" id="L17">    public static String playerSprite = &quot;../assets/Sprites/Player/player_sprites.png&quot;;</span>
    // Hitboxes
    public Rectangle sprite, feet, eventHitbox;
    public float centreX, centreY;
<span class="fc" id="L21">    public int direction = 2; // 0 = up, 1 = right, 2 = down, 3 = left (like a clock)</span>
    public static final int up = 0;
    public static final int right = 1;
    public static final int left =3;
    public static final int down = 2;
    private TextureRegion currentFrame;
<span class="fc" id="L27">    private float stateTime = 0;</span>
    private final Array&lt;Animation&lt;TextureRegion&gt;&gt; walkingAnimation, idleAnimation;
    // Stats
<span class="fc" id="L30">    public float speed = 1000f;</span>
    public Array&lt;GameObject&gt; collidables;
<span class="fc" id="L32">    public int scale = 4;</span>
    private Rectangle bounds;
    private GameObject closestObject;
    public boolean frozen, moving;

    /**
     * A player character, contains methods to move the player and update animations, also includes collision handling
     * and can be used to trigger events of objects near the player.
     * Includes a feet hitbox for collision and an event hitbox for triggering objects.
     * Call move() then draw the result of getCurrentAnimation() to use
     *
     * @param avatar &quot;avatar1&quot; for the more masculine character, &quot;avatar2&quot; for the more feminine character,
     *               player animations are packed in the player_sprites atlas
     */
<span class="fc" id="L46">    public Player (String avatar) {</span>
        // Load the player's textures from the atlas
<span class="fc" id="L48">        TextureAtlas playerAtlas = new TextureAtlas(Gdx.files.internal(atlasConfig));</span>

<span class="fc" id="L50">        walkingAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;(4);</span>
<span class="fc" id="L51">        idleAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;(4);</span>

        // Load walking animation from Sprite atlas
<span class="fc" id="L54">        walkingAnimation.add(</span>
<span class="fc" id="L55">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L56">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L57">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L58">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_left&quot;), Animation.PlayMode.LOOP));</span>
        // Load idle animation
<span class="fc" id="L60">        idleAnimation.add(</span>
<span class="fc" id="L61">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L62">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L63">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="fc" id="L64">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_left&quot;), Animation.PlayMode.LOOP)</span>
        );

<span class="fc" id="L67">        collidables = new Array&lt;GameObject&gt;();</span>

        // Sprite is a rectangle covering the whole player
<span class="fc" id="L70">        sprite = new Rectangle(0, 0, 17*scale, 28*scale);</span>

        // Feet is a rectangle just covering the player's feet, so is better for collision
<span class="fc" id="L73">        feet = new Rectangle(4*scale, 0, 9*scale, 7*scale);</span>

        // Hitbox for triggering events with objects
<span class="fc" id="L76">        float hitboxScaleX = 2.2f;</span>
<span class="fc" id="L77">        float hitboxScaley = 1.7f;</span>
<span class="fc" id="L78">        eventHitbox = new Rectangle(</span>
<span class="fc" id="L79">                sprite.getX() - (sprite.getWidth()*hitboxScaleX - sprite.getWidth()) / 2,</span>
<span class="fc" id="L80">                sprite.getY() - (sprite.getHeight()*hitboxScaley - sprite.getHeight()) / 2,</span>
<span class="fc" id="L81">                sprite.getWidth()*hitboxScaleX,</span>
<span class="fc" id="L82">                sprite.getHeight()*hitboxScaley</span>
        );

<span class="fc" id="L85">    }</span>

    /**
     * Handles all the logic involved in moving the player given keyboard inputs
     * If the player encounters an object, they will not be alowed to move into the space, but will attempt to
     * 'slide' off of it.
     * Also updates the player's animation
     *
     * &lt;p&gt;&lt;/p&gt;
     *
     * Also locates the nearest object after moving, which can be used to trigger events
     *
     * @param delta The time passed since the previous render
     */
    public void move (float delta) {
        // Updates the player's position based on keys being pressed
        // Also updates the direction they are facing, and whether they are currently moving
        // And also does collision

<span class="nc" id="L104">        moving = false;</span>
        // To check collision, store the player's current position
<span class="nc" id="L106">        float oldX = sprite.x;</span>
<span class="nc" id="L107">        float oldY = sprite.y;</span>
<span class="nc" id="L108">        float oldFeetX = feet.x;</span>

        // If not frozen, react to keyboard input presses
<span class="nc bnc" id="L111" title="All 2 branches missed.">        if (!frozen) {</span>
            // Move the player and their 2 other hitboxes
<span class="nc" id="L113">            moving = false;</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {</span>
<span class="nc" id="L115">                direction = movePlayer(left,speed,delta);</span>
<span class="nc" id="L116">                moving = true;</span>
            }
<span class="nc bnc" id="L118" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {</span>
<span class="nc" id="L119">                direction = movePlayer(right,speed,delta);</span>
<span class="nc" id="L120">                moving = true;</span>
            }
<span class="nc bnc" id="L122" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.UP) || Gdx.input.isKeyPressed(Input.Keys.W)) {</span>
<span class="nc" id="L123">                direction = movePlayer(up,speed,delta);</span>
<span class="nc" id="L124">                moving = true;</span>
            }
<span class="nc bnc" id="L126" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S)) {</span>
<span class="nc" id="L127">                direction = movePlayer(down,speed,delta);</span>
<span class="nc" id="L128">                moving = true;</span>
            }

            // Check if the player's feet are inside an object, if they are, move them back in that axis
<span class="nc bnc" id="L132" title="All 2 branches missed.">            for (GameObject object : this.collidables) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                if (feet.overlaps(object)) {</span>
                    // Find the direction that the player needs to be moved back to
                    // Reset x
<span class="nc bnc" id="L136" title="All 4 branches missed.">                    if (!(oldFeetX &lt; object.x + object.width &amp;&amp; oldFeetX + feet.width &gt; object.x)) {</span>
<span class="nc" id="L137">                        this.setX(oldX);</span>
                    }
                    // If overlapping in y direction
<span class="nc bnc" id="L140" title="All 4 branches missed.">                    if (!(oldY &lt; object.y + object.height &amp;&amp; oldY + feet.height &gt; object.y)) {</span>
<span class="nc" id="L141">                        this.setY(oldY);</span>
                    }
                    // The above two are essentially the same code as Rectangle.overlaps()
                    // Just separated into the x and y dimensions
                }
<span class="nc" id="L146">            }</span>


            // Check the player is in bounds
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (bounds != null) {</span>
                // If player is out of bounds, move them back
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (feet.getX() &lt; bounds.getX()) {</span>
<span class="nc" id="L153">                    sprite.x = bounds.getX()-4*scale;</span>
<span class="nc" id="L154">                    feet.x = sprite.x + 4*scale;</span>
                }
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (feet.getX()+feet.getWidth() &gt; bounds.getWidth()) {</span>
<span class="nc" id="L157">                    sprite.x = (bounds.getWidth() - feet.getWidth()) - (4*scale);</span>
<span class="nc" id="L158">                    feet.x = sprite.x + 4*scale;</span>
                }
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (feet.getY() &lt; bounds.getY()) {</span>
<span class="nc" id="L161">                    sprite.y = bounds.getY();</span>
<span class="nc" id="L162">                    feet.y = bounds.getY();</span>
                }
<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (feet.getY()+feet.getHeight() &gt; bounds.getHeight()) {</span>
<span class="nc" id="L165">                    sprite.y = bounds.getHeight()-feet.getHeight();</span>
<span class="nc" id="L166">                    feet.y = sprite.y;</span>
                }
            }
        }



        // Find the closest object to the player so they can interact with it
<span class="nc" id="L174">        recalcCentre(); // Just recalculates the centre of the player now we have moved them</span>
<span class="nc" id="L175">        float distance = -1;</span>
<span class="nc" id="L176">        closestObject = null;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        for (GameObject object : this.collidables) {</span>
            // Check if this object is even interactable
<span class="nc bnc" id="L179" title="All 4 branches missed.">            if (object.get(&quot;event&quot;) != null || object.get(&quot;text&quot;) != null) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (eventHitbox.overlaps(object)) {</span>
                    // Check if this is the closest object to the player
<span class="nc bnc" id="L182" title="All 4 branches missed.">                    if (distance == -1 || distanceFrom(object) &lt; distance) {</span>
<span class="nc" id="L183">                        closestObject = object;</span>
<span class="nc" id="L184">                        distance = distanceFrom(object);</span>
                    }
                }
            }
<span class="nc" id="L188">        }</span>

        // Increment the animation
<span class="nc" id="L191">        updateAnimation();</span>

<span class="nc" id="L193">    }</span>

    /**
     * Moves player in direction specified,
     * @param direction &quot;left&quot;,&quot;right&quot;,&quot;up&quot;, or &quot;down&quot; to indicate which direction to go in
     * @param speed
     * @param delta
     * @return
     */
    public int movePlayer(int direction,float speed, float delta){
        // Direction
<span class="fc" id="L204">        int directionNum = -1;</span>
<span class="fc bfc" id="L205" title="All 5 branches covered.">        switch(direction) {</span>
            case Player.left:
<span class="fc" id="L207">                this.setX(sprite.getX() - speed * delta); // Note: Setting all the values with a constant delta removes hitbox desyncing issues</span>
<span class="fc" id="L208">                break;</span>
            case Player.right:
<span class="fc" id="L210">                this.setX(sprite.getX() + speed * delta);</span>
<span class="fc" id="L211">                break;</span>
            case Player.up:
<span class="fc" id="L213">                this.setY(sprite.getY() + speed * delta);</span>
<span class="fc" id="L214">                break;</span>
            case Player.down:
<span class="fc" id="L216">                this.setY(sprite.getY() - speed * delta);</span>
<span class="fc" id="L217">                break;</span>
            default:
<span class="fc" id="L219">                throw new IllegalArgumentException(&quot;Direction must be up, down, left, or right.&quot;);</span>
        }
<span class="fc" id="L221">        return direction;</span>
    }

    /**
     * Advances the current animation based on the time since the last render
     * The animation frame of the player can be grabbed with getCurrentFrame
     */
    public void updateAnimation() {
<span class="nc" id="L229">        stateTime += Gdx.graphics.getDeltaTime();</span>
        // Set the current frame of the animation
        // Show a different animation if the player is moving vs idling
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (moving) {</span>
<span class="nc" id="L233">            currentFrame = walkingAnimation.get(direction).getKeyFrame(stateTime);</span>
        } else {
<span class="nc" id="L235">            currentFrame = idleAnimation.get(direction).getKeyFrame(stateTime);</span>
        }
<span class="nc" id="L237">    }</span>

    /**
     * Returns whether the player's eventHitbox overlaps an object
     * Call getClosestObject to get the nearest
     *
     * @return true if a player is near enough an object to interact with it
     */
    public boolean nearObject() {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        return closestObject != null;</span>
    }

    /**
     * Returns the object that is closest to the player, calculated during move()
     *
     * @return A GameObject that is closest
     */
    public GameObject getClosestObject () {
<span class="nc" id="L255">        return closestObject;</span>
    }

    /**
     * Returns if the player is moving or not
     *
     * @return true if the player is moving
     */
    public boolean isMoving() {
<span class="nc" id="L264">        return moving;</span>
    }

    /**
     * Sets the player's state to moving or not moving, a not moving character will just display an idle animation
     *
     * @param moving The boolean to set moving to
     */
    public void setMoving(boolean moving) {
<span class="nc" id="L273">        this.moving = moving;</span>
<span class="nc" id="L274">    }</span>


    /**
     * Returns the current frame the player's animation is on
     *
     * @return TextureRegion the frame of the player's animation
     */
    public TextureRegion getCurrentFrame () {
        // Returns the current frame the player animation is on
<span class="nc" id="L284">        return currentFrame;</span>
    }

    /**
     * Sets the objects the player cannot move into as an Array of GameObjects
     *
     * @param collidables An array of GameObjects that the player should collide with
     */
    public void setCollidables (Array&lt;GameObject&gt; collidables) {
<span class="nc" id="L293">        this.collidables = collidables;</span>
<span class="nc" id="L294">    }</span>

    /**
     * Adds a GameObeject to the player's list of collidable objects
     *
     * @param object a GameObject for the player to collide with
     */
    public void addCollidable (GameObject object) {
<span class="nc" id="L302">        this.collidables.add(object);</span>
<span class="nc" id="L303">    }</span>

    /**
     * @return The X coordinate of the player
     */
    public float getX () {
<span class="fc" id="L309">        return sprite.getX();</span>
    }
    /**
     * @return The Y coordinate of the player
     */
    public float getY () {
<span class="fc" id="L315">        return sprite.getY();</span>
    }

    /**
     * @return The X coordinate of the centre point of the player's sprite rectangle
     */
    public float getCentreX () {
<span class="nc" id="L322">        return centreX;</span>
    }
    /**
     * @return The Y coordinate of the centre point of the player's sprite rectangle
     */
    public float getCentreY () {
<span class="nc" id="L328">        return centreY;</span>
    }

    /**
     * @return The Vector3 representation of the bottom left corner of the player's sprite hitbox
     */
    public Vector3 getPosAsVec3() {
<span class="nc" id="L335">        return new Vector3(</span>
<span class="nc" id="L336">                sprite.getX(),</span>
<span class="nc" id="L337">                sprite.getY(),</span>
                0
        );
    }

    /**
     * Sets the x coordinate of the player, updating all 3 hitboxes at once as opposed to just the sprite rectangle
     */
    public void setX (float x) {
<span class="fc" id="L346">        this.sprite.setX(x);</span>
<span class="fc" id="L347">        this.feet.setX(x + 4*scale);</span>
<span class="fc" id="L348">        this.eventHitbox.setX(this.sprite.getX() - (this.eventHitbox.getWidth() - sprite.getWidth()) / 2);</span>
<span class="fc" id="L349">        this.recalcCentre();</span>
<span class="fc" id="L350">    }</span>
    /**
     * Sets the Y coordinate of the player, updating all 3 hitboxes at once as opposed to just the sprite rectangle
     */
    public void setY (float y) {
<span class="fc" id="L355">        this.sprite.setY(y);</span>
<span class="fc" id="L356">        this.feet.setY(y);</span>
<span class="fc" id="L357">        this.eventHitbox.setY(this.sprite.getY() - (this.eventHitbox.getHeight() - sprite.getHeight()) / 2);</span>
<span class="fc" id="L358">        this.recalcCentre();</span>
<span class="fc" id="L359">    }</span>

    /**
     *
     * @param x The X coordinate to set the player to
     * @param y The Y coordinate to set the player to
     */
    public void setPos (float x, float y) {
<span class="nc" id="L367">        this.setX(x);</span>
<span class="nc" id="L368">        this.setY(y);</span>
<span class="nc" id="L369">    }</span>

    /**
     * Set a large rectangle that the player should be kept inside, set to null to set no bounds
     *
     * @param bounds The bounds of the playable map
     */
    public void setBounds (Rectangle bounds) {
        // Set a rectangle that the player should not leave
<span class="nc" id="L378">        this.bounds = bounds;</span>
<span class="nc" id="L379">    }</span>

    /**
     * Returns the euclidian distance from a GameObject to the centre of the player
     *
     * @param object The object to get the distance from
     * @return The distance from the object
     */
    private float distanceFrom (GameObject object) {
<span class="nc" id="L388">        return (float) Math.sqrt((Math.pow((centreX - object.centreX), 2) + Math.pow((centreY - object.centreY), 2)));</span>
    }

    /**
     * Recalculates the centre of the player, useful after moving the player
     */
    private void recalcCentre() {
<span class="fc" id="L395">        centreX = sprite.getX() + sprite.getWidth() / 2;</span>
<span class="fc" id="L396">        centreY = sprite.getY() + sprite.getHeight() / 2;</span>
<span class="fc" id="L397">    }</span>

    /**
     * Sets the player to frozen, a frozen player can be set to ignore keyboard inputs in render
     *
     * @param freeze The value to set frozen to
     */
    public void setFrozen (boolean freeze) {
<span class="nc" id="L405">        this.frozen = freeze;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        if (freeze) {</span>
            // Set to non-moving frame
<span class="nc" id="L408">            currentFrame = idleAnimation.get(direction).getKeyFrame(stateTime);</span>
        }
<span class="nc" id="L410">    }</span>

    /**
     * @return true if the player is frozen
     */
    public boolean isFrozen () {
<span class="nc" id="L416">        return this.frozen;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>